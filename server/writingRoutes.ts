import type { Express, Request, Response } from "express";
import { requireAuth } from "./auth";
import { projectStorage } from "./projectStorage";
import { storage } from "./storage";
import {
  runWritingPipeline,
  type WritingRequest,
  type WritingSource,
  type WritingSSEEvent,
} from "./writingPipeline";
import type { CitationData } from "@shared/schema";

const MAX_SOURCE_EXCERPT_CHARS = 700;
const MAX_SOURCE_FULLTEXT_CHARS = 7000;

function clipText(text: string | null | undefined, maxChars: number): string {
  if (!text) return "";
  const normalized = text.replace(/\s+/g, " ").trim();
  if (!normalized) return "";
  if (normalized.length <= maxChars) return normalized;
  return `${normalized.slice(0, maxChars).trimEnd()}...`;
}

function buildAuthorLabel(citationData: CitationData | null): string {
  if (!citationData?.authors?.length) return "Unknown Author";
  return citationData.authors
    .map((author) => `${author.firstName} ${author.lastName}`.trim())
    .filter(Boolean)
    .join(", ");
}

function toSafeFilename(topic: string): string {
  const base = topic
    .replace(/[\\/:*?"<>|]/g, "_")
    .replace(/\s+/g, " ")
    .trim()
    .slice(0, 80);
  const datePart = new Date().toISOString().slice(0, 10);
  return `${base || "generated-paper"}-${datePart}.md`;
}

async function savePaperToProject(
  projectId: string,
  topic: string,
  fullText: string
): Promise<{
  documentId: string;
  projectDocumentId: string;
  filename: string;
  savedAt: number;
}> {
  const filename = toSafeFilename(topic);
  const summary = clipText(fullText, 400);

  const createdDocument = await storage.createDocument({
    filename,
    fullText,
    summary: summary || "AI-generated paper",
    userIntent: `AI-generated paper for topic: ${topic}`,
  });

  const projectDocument = await projectStorage.addDocumentToProject({
    projectId,
    documentId: createdDocument.id,
    roleInProject: "AI-generated draft",
    projectContext: `Generated by Writing pipeline on ${new Date().toISOString()}`,
  });

  return {
    documentId: createdDocument.id,
    projectDocumentId: projectDocument.id,
    filename: createdDocument.filename,
    savedAt: Date.now(),
  };
}

export function registerWritingRoutes(app: Express): void {
  // POST /api/write - Start writing pipeline, stream results via SSE
  app.post("/api/write", requireAuth, async (req: Request, res: Response) => {
    try {
      const body = req.body as Partial<WritingRequest> & {
        sourceDocumentIds?: unknown;
      };

      // Validate required fields
      if (!body.topic || typeof body.topic !== "string" || body.topic.trim().length === 0) {
        return res.status(400).json({ error: "Topic is required" });
      }

      const hasSourceSelection = Array.isArray(body.sourceDocumentIds);
      const sourceDocumentIds = hasSourceSelection
        ? (body.sourceDocumentIds as unknown[]).filter((id): id is string => typeof id === "string")
        : undefined;

      const request: WritingRequest = {
        topic: body.topic.trim(),
        annotationIds: Array.isArray(body.annotationIds) ? body.annotationIds : [],
        sourceDocumentIds,
        projectId: body.projectId || undefined,
        citationStyle: body.citationStyle || "chicago",
        tone: body.tone || "academic",
        targetLength: body.targetLength || "medium",
        noEnDashes: body.noEnDashes ?? false,
        deepWrite: body.deepWrite ?? false,
      };

      const sources: WritingSource[] = [];
      const seenSourceIds = new Set<string>();
      const addSource = (source: WritingSource) => {
        if (seenSourceIds.has(source.id)) return;
        seenSourceIds.add(source.id);
        sources.push(source);
      };

      let projectDocs: Awaited<ReturnType<typeof projectStorage.getProjectDocumentsByProject>> = [];

      if (request.projectId) {
        projectDocs = await projectStorage.getProjectDocumentsByProject(request.projectId);

        const selectedProjectDocs = hasSourceSelection
          ? projectDocs.filter((projectDoc) => sourceDocumentIds?.includes(projectDoc.id))
          : projectDocs;

        for (const projectDoc of selectedProjectDocs) {
          const fullDoc = await storage.getDocument(projectDoc.documentId);
          if (!fullDoc) continue;

          const citationData = (projectDoc.citationData as CitationData | null) || null;
          const summaryExcerpt =
            clipText(projectDoc.document.summary, MAX_SOURCE_EXCERPT_CHARS) ||
            clipText(fullDoc.fullText, MAX_SOURCE_EXCERPT_CHARS);

          addSource({
            id: projectDoc.id,
            kind: "project_document",
            title: citationData?.title || projectDoc.document.filename,
            author: buildAuthorLabel(citationData),
            excerpt: summaryExcerpt || "No summary available.",
            fullText:
              clipText(fullDoc.fullText, MAX_SOURCE_FULLTEXT_CHARS) ||
              summaryExcerpt ||
              "No source text available.",
            category: "project_source",
            note: projectDoc.roleInProject || null,
            citationData,
            documentFilename: projectDoc.document.filename,
          });
        }
      }

      // Backward compatibility: annotation-based writing requests
      if (request.annotationIds.length > 0 && request.projectId) {
        const projectDocById = new Map(projectDocs.map((projectDoc) => [projectDoc.id, projectDoc]));

        for (const annotationId of request.annotationIds) {
          // Try project annotations first
          const projectAnnotation = await projectStorage.getProjectAnnotation(annotationId);
          if (projectAnnotation) {
            const projectDoc = projectDocById.get(projectAnnotation.projectDocumentId);
            const citationData = (projectDoc?.citationData as CitationData | null) || null;
            const docFilename = projectDoc?.document?.filename || "Unknown Source";

            addSource({
              id: projectAnnotation.id,
              kind: "annotation",
              title: citationData?.title || docFilename,
              author: buildAuthorLabel(citationData),
              excerpt: clipText(projectAnnotation.highlightedText, MAX_SOURCE_EXCERPT_CHARS),
              fullText: clipText(
                `${projectAnnotation.highlightedText}\n${projectAnnotation.note ?? ""}`,
                MAX_SOURCE_FULLTEXT_CHARS
              ),
              category: projectAnnotation.category,
              note: projectAnnotation.note,
              citationData,
              documentFilename: docFilename,
            });
            continue;
          }

          // Fall back to legacy annotations
          const legacyAnnotation = await storage.getAnnotation(annotationId);
          if (legacyAnnotation) {
            const doc = await storage.getDocument(legacyAnnotation.documentId);
            addSource({
              id: legacyAnnotation.id,
              kind: "annotation",
              title: doc?.filename || "Legacy Source",
              author: "Unknown Author",
              excerpt: clipText(legacyAnnotation.highlightedText, MAX_SOURCE_EXCERPT_CHARS),
              fullText: clipText(
                `${legacyAnnotation.highlightedText}\n${legacyAnnotation.note ?? ""}`,
                MAX_SOURCE_FULLTEXT_CHARS
              ),
              category: legacyAnnotation.category,
              note: legacyAnnotation.note,
              citationData: null,
              documentFilename: doc?.filename || "Unknown Source",
            });
          }
        }
      }

      // Set up SSE response
      res.writeHead(200, {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
        "X-Accel-Buffering": "no",
      });

      // Helper to send SSE events
      const sendEvent = (event: WritingSSEEvent) => {
        res.write(`data: ${JSON.stringify(event)}\n\n`);
      };

      // Handle client disconnect
      let aborted = false;
      let completedFullText = "";

      req.on("close", () => {
        aborted = true;
      });

      // Run the pipeline
      await runWritingPipeline(request, sources, (event) => {
        if (event.type === "complete" && event.fullText) {
          completedFullText = event.fullText;
        }
        if (!aborted) {
          sendEvent(event);
        }
      });

      if (!aborted && request.projectId && completedFullText.trim()) {
        try {
          const savedPaper = await savePaperToProject(
            request.projectId,
            request.topic,
            completedFullText
          );
          sendEvent({
            type: "saved",
            message: `Saved to project as "${savedPaper.filename}"`,
            savedPaper,
          });
        } catch (saveError) {
          sendEvent({
            type: "status",
            phase: "saving",
            message: `Generated paper but could not save to project: ${
              saveError instanceof Error ? saveError.message : "Unknown save error"
            }`,
          });
        }
      }

      // End the stream
      if (!aborted) {
        res.write("data: [DONE]\n\n");
        res.end();
      }
    } catch (error) {
      console.error("Writing pipeline error:", error);
      // If headers haven't been sent yet, send a JSON error
      if (!res.headersSent) {
        res.status(500).json({
          error: error instanceof Error ? error.message : "Writing pipeline failed",
        });
      } else {
        // Headers already sent (SSE mode), send error event
        const errorEvent: WritingSSEEvent = {
          type: "error",
          error: error instanceof Error ? error.message : "Writing pipeline failed",
        };
        res.write(`data: ${JSON.stringify(errorEvent)}\n\n`);
        res.end();
      }
    }
  });

  // GET /api/write/history - Placeholder for future writing session history
  app.get("/api/write/history", requireAuth, async (_req: Request, res: Response) => {
    // Future: return list of previous writing sessions
    res.json([]);
  });
}
